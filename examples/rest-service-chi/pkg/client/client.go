// Code generated by GG version dev. DO NOT EDIT.

//go:build !gg

package client

import (
	"bytes"
	"compress/gzip"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	dto "github.com/555f/gg/examples/rest-service-chi/pkg/dto"
	errors "github.com/555f/gg/examples/rest-service-chi/pkg/errors"
	gocleanhttp "github.com/hashicorp/go-cleanhttp"
	prometheus "github.com/prometheus/client_golang/prometheus"
	promhttp "github.com/prometheus/client_golang/prometheus/promhttp"
	"io"
	"net"
	"net/http"
	"strconv"
	"strings"
)

type contextKey string

const methodContextKey contextKey = "method"
const shortMethodContextKey contextKey = "shortMethod"
const scopeNameContextKey contextKey = "scopeName"

func labelFromContext(lblName string, ctxKey contextKey) promhttp.Option {
	return promhttp.WithLabelFromCtx(lblName, func(ctx context.Context) string {
		v, _ := ctx.Value(ctxKey).(string)
		return v
	})
}
func instrumentRoundTripperErrCounter(counter *prometheus.CounterVec, next http.RoundTripper) promhttp.RoundTripperFunc {
	return func(r *http.Request) (*http.Response, error) {
		labels := prometheus.Labels{"method": strings.ToLower(r.Method)}
		labels["methodNameFull"], _ = r.Context().Value(methodContextKey).(string)
		labels["methodNameShort"], _ = r.Context().Value(shortMethodContextKey).(string)
		labels["scopeName"], _ = r.Context().Value(scopeNameContextKey).(string)
		labels["code"] = ""
		resp, err := next.RoundTrip(r)
		if err != nil {
			var errType string
			switch e := err.(type) {
			default:
				errType = err.Error()
			case *tls.CertificateVerificationError:
				errType = "failedVerifyCertificate"
			case net.Error:
				errType += "net."
				if e.Timeout() {
					errType += "timeout."
				}
				switch ee := e.(type) {
				case *net.ParseError:
					errType += "parse"
				case *net.InvalidAddrError:
					errType += "invalidAddr"
				case *net.UnknownNetworkError:
					errType += "unknownNetwork"
				case *net.DNSError:
					errType += "dns"
				case *net.OpError:
					errType += ee.Net + "." + ee.Op
				}
			}
			labels["errorCode"] = errType
			counter.With(labels).Add(1)
		} else if resp.StatusCode > 399 {
			labels["code"] = strconv.Itoa(resp.StatusCode)
			labels["errorCode"] = "respFailed"
			counter.With(labels).Add(1)
		}
		return resp, err
	}
}

type PrometheusCollector interface {
	prometheus.Collector
	Requests() *prometheus.CounterVec
	ErrRequests() *prometheus.CounterVec
	Duration() *prometheus.HistogramVec
}
type ClientBeforeFunc func(context.Context, *http.Request) (context.Context, error)
type ClientAfterFunc func(context.Context, *http.Response) context.Context
type clientOptions struct {
	ctx    context.Context
	before []ClientBeforeFunc
	after  []ClientAfterFunc
	client *http.Client
}
type ClientOption func(*clientOptions)

func WithContext(ctx context.Context) ClientOption {
	return func(o *clientOptions) {
		o.ctx = ctx
	}
}
func WithClient(client *http.Client) ClientOption {
	return func(o *clientOptions) {
		o.client = client
	}
}
func WithPrometheusCollector(c PrometheusCollector) ClientOption {
	return func(o *clientOptions) {
		if o.client.Transport == nil {
			panic("no transport is set for the http client")
		}
		o.client.Transport = instrumentRoundTripperErrCounter(c.ErrRequests(), promhttp.InstrumentRoundTripperCounter(c.Requests(), promhttp.InstrumentRoundTripperDuration(c.Duration(), o.client.Transport, labelFromContext("methodNameShort", shortMethodContextKey), labelFromContext("methodNameFull", methodContextKey), labelFromContext("scopeName", scopeNameContextKey)), labelFromContext("methodNameShort", shortMethodContextKey), labelFromContext("methodNameFull", methodContextKey), labelFromContext("scopeName", scopeNameContextKey)))
	}
}
func Before(before ...ClientBeforeFunc) ClientOption {
	return func(o *clientOptions) {
		o.before = append(o.before, before...)
	}
}
func After(after ...ClientAfterFunc) ClientOption {
	return func(o *clientOptions) {
		o.after = append(o.after, after...)
	}
}

const profileControllerScopeName = "controller"

type ProfileControllerClient struct {
	target string
	opts   *clientOptions
}

const createShortName = "(controller.ProfileController).Create"
const createFullName = "(github.com/555f/gg/examples/rest-service-chi/internal/usecase/controller.ProfileController).Create"

type ProfileControllerCreateRequest struct {
	c      *ProfileControllerClient
	client *http.Client
	opts   *clientOptions
	params struct {
		firstName string
		lastName  string
		address   *string
		zip       int
	}
}

func (r *ProfileControllerCreateRequest) SetAddress(address string) *ProfileControllerCreateRequest {
	r.params.address = &address
	return r
}
func (r *ProfileControllerClient) Create(firstName string, lastName string, address string, zip int) (profile *dto.Profile, err error) {
	profile, err = r.CreateRequest(firstName, lastName, zip).SetAddress(address).Execute()
	return
}
func (r *ProfileControllerClient) CreateRequest(firstName string, lastName string, zip int) *ProfileControllerCreateRequest {
	m := &ProfileControllerCreateRequest{client: r.opts.client, opts: &clientOptions{ctx: context.TODO()}, c: r}
	m.params.firstName = firstName
	m.params.lastName = lastName
	m.params.zip = zip
	return m
}
func (r *ProfileControllerCreateRequest) Execute(opts ...ClientOption) (profile *dto.Profile, err error) {
	for _, o := range opts {
		o(r.opts)
	}
	ctx, cancel := context.WithCancel(r.opts.ctx)
	path := "/profiles"
	r.opts.ctx = context.WithValue(r.opts.ctx, methodContextKey, createFullName)
	r.opts.ctx = context.WithValue(r.opts.ctx, shortMethodContextKey, createShortName)
	r.opts.ctx = context.WithValue(r.opts.ctx, scopeNameContextKey, profileControllerScopeName)
	req, err := http.NewRequestWithContext(r.opts.ctx, "POST", r.c.target+path, nil)
	if err != nil {
		cancel()
		return
	}

	req.Header.Add("Content-Type", "application/json")
	var body struct {
		FirstName string  `json:"firstName"`
		LastName  string  `json:"lastName"`
		Address   *string `json:"address,omitempty"`
		Zip       int     `json:"zip"`
	}
	body.FirstName = r.params.firstName
	body.LastName = r.params.lastName
	body.Address = r.params.address
	body.Zip = r.params.zip
	var reqData bytes.Buffer
	err = json.NewEncoder(&reqData).Encode(body)
	if err != nil {
		cancel()
		return
	}
	req.Body = io.NopCloser(&reqData)
	before := append(r.c.opts.before, r.opts.before...)
	for _, before := range before {
		ctx, err = before(ctx, req)
		if err != nil {
			cancel()
			return
		}
	}
	resp, err := r.client.Do(req)
	if err != nil {
		cancel()
		return
	}
	after := append(r.c.opts.after, r.opts.after...)
	for _, after := range after {
		ctx = after(ctx, resp)
	}
	defer resp.Body.Close()
	defer cancel()
	if resp.StatusCode > 399 {
		if resp.Body == http.NoBody {
			err = fmt.Errorf("http error %d", resp.StatusCode)
			return
		}
		var errorWrapper errors.ErrorWrapper
		var bytes []byte
		bytes, err = io.ReadAll(resp.Body)
		if err != nil {
			err = fmt.Errorf("http error %d: %w", resp.StatusCode, err)
			return
		}
		err = json.Unmarshal(bytes, &errorWrapper)
		if err != nil {
			err = fmt.Errorf("http error %d unmarshal data %s: %w", resp.StatusCode, bytes, err)
			return
		}
		err = &errors.DefaultError{Data: errorWrapper.Data, ErrorText: errorWrapper.ErrorText, Code: errorWrapper.Code}
		return
	}

	var respBody struct {
		Profile *dto.Profile `json:"profile"`
	}
	var reader io.ReadCloser
	switch resp.Header.Get("Content-Encoding") {
	default:
		reader = resp.Body
	case "gzip":
		reader, err = gzip.NewReader(resp.Body)
		if err != nil {
			return
		}
		defer reader.Close()
	}
	err = json.NewDecoder(reader).Decode(&respBody)
	if err != nil {
		return
	}
	return respBody.Profile, nil
}

const downloadFileShortName = "(controller.ProfileController).DownloadFile"
const downloadFileFullName = "(github.com/555f/gg/examples/rest-service-chi/internal/usecase/controller.ProfileController).DownloadFile"

type ProfileControllerDownloadFileRequest struct {
	c      *ProfileControllerClient
	client *http.Client
	opts   *clientOptions
	params struct {
		id        string
		onlyCloud *bool
	}
}

func (r *ProfileControllerDownloadFileRequest) SetOnlyCloud(onlyCloud bool) *ProfileControllerDownloadFileRequest {
	r.params.onlyCloud = &onlyCloud
	return r
}
func (r *ProfileControllerClient) DownloadFile(id string, onlyCloud bool) (data string, err error) {
	data, err = r.DownloadFileRequest(id).SetOnlyCloud(onlyCloud).Execute()
	return
}
func (r *ProfileControllerClient) DownloadFileRequest(id string) *ProfileControllerDownloadFileRequest {
	m := &ProfileControllerDownloadFileRequest{client: r.opts.client, opts: &clientOptions{ctx: context.TODO()}, c: r}
	m.params.id = id
	return m
}
func (r *ProfileControllerDownloadFileRequest) Execute(opts ...ClientOption) (data string, err error) {
	for _, o := range opts {
		o(r.opts)
	}
	ctx, cancel := context.WithCancel(r.opts.ctx)
	path := fmt.Sprintf("/profiles/%s/file", r.params.id)
	r.opts.ctx = context.WithValue(r.opts.ctx, methodContextKey, downloadFileFullName)
	r.opts.ctx = context.WithValue(r.opts.ctx, shortMethodContextKey, downloadFileShortName)
	r.opts.ctx = context.WithValue(r.opts.ctx, scopeNameContextKey, profileControllerScopeName)
	req, err := http.NewRequestWithContext(r.opts.ctx, "GET", r.c.target+path, nil)
	if err != nil {
		cancel()
		return
	}

	q := req.URL.Query()
	if r.params.onlyCloud != nil {
		q.Add("onlyCloud", strconv.FormatBool(*r.params.onlyCloud))
	}
	req.URL.RawQuery = q.Encode()
	before := append(r.c.opts.before, r.opts.before...)
	for _, before := range before {
		ctx, err = before(ctx, req)
		if err != nil {
			cancel()
			return
		}
	}
	resp, err := r.client.Do(req)
	if err != nil {
		cancel()
		return
	}
	after := append(r.c.opts.after, r.opts.after...)
	for _, after := range after {
		ctx = after(ctx, resp)
	}
	defer resp.Body.Close()
	defer cancel()
	if resp.StatusCode > 399 {
		if resp.Body == http.NoBody {
			err = fmt.Errorf("http error %d", resp.StatusCode)
			return
		}
		var errorWrapper errors.ErrorWrapper
		var bytes []byte
		bytes, err = io.ReadAll(resp.Body)
		if err != nil {
			err = fmt.Errorf("http error %d: %w", resp.StatusCode, err)
			return
		}
		err = json.Unmarshal(bytes, &errorWrapper)
		if err != nil {
			err = fmt.Errorf("http error %d unmarshal data %s: %w", resp.StatusCode, bytes, err)
			return
		}
		err = &errors.DefaultError{Data: errorWrapper.Data, ErrorText: errorWrapper.ErrorText, Code: errorWrapper.Code}
		return
	}

	var respBody struct {
		Data string `json:"data"`
	}
	var reader io.ReadCloser
	switch resp.Header.Get("Content-Encoding") {
	default:
		reader = resp.Body
	case "gzip":
		reader, err = gzip.NewReader(resp.Body)
		if err != nil {
			return
		}
		defer reader.Close()
	}
	err = json.NewDecoder(reader).Decode(&respBody)
	if err != nil {
		return
	}
	return respBody.Data, nil
}

const removeShortName = "(controller.ProfileController).Remove"
const removeFullName = "(github.com/555f/gg/examples/rest-service-chi/internal/usecase/controller.ProfileController).Remove"

type ProfileControllerRemoveRequest struct {
	c      *ProfileControllerClient
	client *http.Client
	opts   *clientOptions
	params struct {
		id string
	}
}

func (r *ProfileControllerClient) Remove(id string) (err error) {
	err = r.RemoveRequest(id).Execute()
	return
}
func (r *ProfileControllerClient) RemoveRequest(id string) *ProfileControllerRemoveRequest {
	m := &ProfileControllerRemoveRequest{client: r.opts.client, opts: &clientOptions{ctx: context.TODO()}, c: r}
	m.params.id = id
	return m
}
func (r *ProfileControllerRemoveRequest) Execute(opts ...ClientOption) (err error) {
	for _, o := range opts {
		o(r.opts)
	}
	ctx, cancel := context.WithCancel(r.opts.ctx)
	path := fmt.Sprintf("/profiles/%s", r.params.id)
	r.opts.ctx = context.WithValue(r.opts.ctx, methodContextKey, removeFullName)
	r.opts.ctx = context.WithValue(r.opts.ctx, shortMethodContextKey, removeShortName)
	r.opts.ctx = context.WithValue(r.opts.ctx, scopeNameContextKey, profileControllerScopeName)
	req, err := http.NewRequestWithContext(r.opts.ctx, "DELETE", r.c.target+path, nil)
	if err != nil {
		cancel()
		return
	}
	before := append(r.c.opts.before, r.opts.before...)
	for _, before := range before {
		ctx, err = before(ctx, req)
		if err != nil {
			cancel()
			return
		}
	}
	resp, err := r.client.Do(req)
	if err != nil {
		cancel()
		return
	}
	after := append(r.c.opts.after, r.opts.after...)
	for _, after := range after {
		ctx = after(ctx, resp)
	}
	defer resp.Body.Close()
	defer cancel()
	if resp.StatusCode > 399 {
		if resp.Body == http.NoBody {
			err = fmt.Errorf("http error %d", resp.StatusCode)
			return
		}
		var errorWrapper errors.ErrorWrapper
		var bytes []byte
		bytes, err = io.ReadAll(resp.Body)
		if err != nil {
			err = fmt.Errorf("http error %d: %w", resp.StatusCode, err)
			return
		}
		err = json.Unmarshal(bytes, &errorWrapper)
		if err != nil {
			err = fmt.Errorf("http error %d unmarshal data %s: %w", resp.StatusCode, bytes, err)
			return
		}
		err = &errors.DefaultError{Data: errorWrapper.Data, ErrorText: errorWrapper.ErrorText, Code: errorWrapper.Code}
		return
	}

	return
}
func NewProfileControllerClient(target string, opts ...ClientOption) *ProfileControllerClient {
	c := &ProfileControllerClient{target: target, opts: &clientOptions{client: gocleanhttp.DefaultClient()}}
	for _, o := range opts {
		o(c.opts)
	}
	return c
}
