package file

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"

	"github.com/555f/gg/pkg/types"

	"github.com/dave/jennifer/jen"
)

var _ File = &GoFile{}

type GoFileOption func(*goFileOpts)

func UseTestPkg() GoFileOption {
	return func(o *goFileOpts) {
		o.useTestPkg = true
	}
}

type goFileOpts struct {
	useTestPkg bool
}

type GoFile struct {
	*jen.File

	version string
	path    string
	pkgPath string
}

func (f *GoFile) SetVersion(version string) {
	f.version = version
}

func (f *GoFile) IsCurrPkg(pkgPath string) bool {
	return strings.EqualFold(f.pkgPath, pkgPath)
}

func (f *GoFile) Qual(pkgPath, name string) func(s *jen.Statement) {
	return func(s *jen.Statement) {
		if f.IsCurrPkg(pkgPath) {
			s.Id(name)
		} else {
			s.Qual(pkgPath, name)
		}
	}
}

func (f *GoFile) Import(pkgPath, name string) func(s *jen.Statement) {
	return f.Qual(pkgPath, name)
}

func (f *GoFile) Path() string {
	return f.path
}

func (f *GoFile) Bytes() ([]byte, error) {
	f.HeaderComment("Code generated by GG version " + f.version + ". DO NOT EDIT.")
	f.Id("//go:build !gg")
	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func NewGoFile(module *types.Module, path string, opts ...GoFileOption) *GoFile {
	o := &goFileOpts{}
	for _, optApply := range opts {
		optApply(o)
	}

	var (
		pkgName, modulePath, packagePath string
	)

	packagePath = strings.Replace(filepath.Dir(path), module.Dir, "", -1)
	packagePath = strings.TrimLeft(packagePath, string(os.PathSeparator))

	pkgName = filepath.Base(packagePath)
	modulePath = module.Path
	pkgName = guessAlias(pkgName)

	if o.useTestPkg {
		packagePath = packagePath + "_test"
		pkgName = pkgName + "_test"
	}

	return &GoFile{
		File:    jen.NewFilePathName(path, pkgName),
		path:    path,
		pkgPath: modulePath + "/" + packagePath,
	}
}
