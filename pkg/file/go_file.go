package file

import (
	"bytes"
	"path"
	"path/filepath"
	"strings"

	"github.com/555f/gg/pkg/types"

	"github.com/dave/jennifer/jen"
)

var _ File = &GoFile{}

type GoFile struct {
	*jen.File
	version     string
	path        string
	packagePath string
	modulePath  string
}

func (f *GoFile) SetVersion(version string) {
	f.version = version
}

func (f *GoFile) IsCurrPkg(pkgPath string) bool {
	return path.Join(f.modulePath, f.packagePath) == pkgPath
}

func (f *GoFile) Qual(pkgPath, name string) func(s *jen.Statement) {
	return func(s *jen.Statement) {
		if f.IsCurrPkg(pkgPath) {
			s.Id(name)
		} else {
			s.Qual(pkgPath, name)
		}
	}
}

func (f *GoFile) Import(pkgPath, name string) func(s *jen.Statement) {
	return f.Qual(pkgPath, name)
}

func (f *GoFile) Path() string {
	return f.path
}

func (f *GoFile) PackagePath() string {
	return f.packagePath
}

func (f *GoFile) Bytes() ([]byte, error) {
	f.HeaderComment("Code generated by GG version " + f.version + ". DO NOT EDIT.")
	f.Id("//go:build !gg")
	var buf bytes.Buffer
	if err := f.Render(&buf); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func NewGoFile(module *types.Module, path string) *GoFile {
	var (
		pkgName, modulePath, packagePath string
	)
	if module != nil {
		packagePath = strings.Replace(filepath.Dir(path), module.Dir, "", -1)

		parts := strings.Split(packagePath, string(filepath.Separator))
		pkgName = parts[len(parts)-1]
		modulePath = module.Path
	} else {
		dirPath := filepath.Dir(path)
		packagePath = filepath.Base(dirPath)
		pkgName = filepath.Base(dirPath)
	}
	return &GoFile{File: jen.NewFilePath(pkgName),
		packagePath: packagePath,
		path:        path,
		modulePath:  modulePath,
	}
}
